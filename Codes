package com.bnp.service;

import com.bnp.model.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
@Service
public class DataService {

    @Value("${finance.api.url}")
    private String financeApiUrl;

    @Value("${kyc.api.url}")
    private String kycApiUrl;

    @Value("${auth.token.url}")
    private String authTokenUrl;

    @Value("${auth.basic.token}")
    private String authBasicToken;

    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;

    public DataService(RestTemplate restTemplate, ObjectMapper objectMapper) {
        this.restTemplate = restTemplate;
        this.objectMapper = objectMapper;
    }

    public String getAccessToken() {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "Basic " + authBasicToken);
            headers.set("Accept", "*/*;version=gamma");
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            HttpEntity<String> request = new HttpEntity<>(null, headers);
            ResponseEntity<String> response = restTemplate.exchange(authTokenUrl, HttpMethod.POST, request, String.class);

            JsonNode root = objectMapper.readTree(response.getBody());
            return root.path("access_token").asText();
        } catch (Exception e) {
            log.error("Failed to retrieve access token", e);
            return null;
        }
    }

    public List<MergedEntity> getMergedEntities() {
        List<MergedEntity> mergedEntities = new ArrayList<>();
        String token = getAccessToken();
        if (token == null) {
            log.error("Access token is null, aborting fetch.");
            return mergedEntities;
        }

        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(token);
            headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
            HttpEntity<Void> request = new HttpEntity<>(headers);

            // Get finance data
            ResponseEntity<String> financeResponse = restTemplate.exchange(financeApiUrl, HttpMethod.GET, request, String.class);
            JsonNode financeRoot = objectMapper.readTree(financeResponse.getBody());
            List<File1Result> financeResults = objectMapper.readerForListOf(File1Result.class)
                    .readValue(financeRoot.path("results"));

            for (File1Result financeEntity : financeResults) {
                List<Identifiers> identifiers = financeEntity.getEntity().getIdentifiers();
                BusinessAddress businessAddress = financeEntity.getEntity().getBusinessAddress();

                if (identifiers == null || identifiers.isEmpty()) continue;

                for (Identifiers id : identifiers) {
                    if (id.getKycId() == null) continue;

                    String kycUrlWithParam = kycApiUrl + "?kycId=" + id.getKycId();
                    ResponseEntity<String> kycResponse = restTemplate.exchange(kycUrlWithParam, HttpMethod.GET, request, String.class);
                    JsonNode kycRoot = objectMapper.readTree(kycResponse.getBody());
                    JsonNode kycResultsNode = kycRoot.path("results");

                    if (!kycResultsNode.isEmpty()) {
                        File2Result kycResult = objectMapper.treeToValue(kycResultsNode.get(0), File2Result.class);

                        MergedEntity merged = new MergedEntity();
                        merged.setIdentifiers(Collections.singletonList(id));
                        merged.setBusinessAddress(businessAddress);
                        merged.setKycSites(kycResult.getKycData().getKycSites());
                        merged.setKycSegment(kycResult.getKycData().getKycSegment());
                        merged.setRiskIndustries(kycResult.getKycData().getRiskIndustry());

                        mergedEntities.add(merged);
                    }
                }
            }

        } catch (Exception e) {
            log.error("Failed to fetch or parse merged entities", e);
        }

        return mergedEntities;
    }

    public void exportMergedEntitiesToFile(String filePath) {
        try {
            List<MergedEntity> mergedEntities = getMergedEntities();
            if (mergedEntities.isEmpty()) {
                log.warn("No merged entities found to export.");
                return;
            }

            File file = new File(filePath);
            File parent = file.getParentFile();
            if (parent != null && !parent.exists()) {
                parent.mkdirs();
            }

            try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {
                writer.write("CRDSCODE;Registration Address;Country;Site BNPP;Site Country;Site Status;KYC Segment;RIC");
                writer.newLine();

                for (MergedEntity entity : mergedEntities) {
                    List<Identifiers> identifiers = entity.getIdentifiers();
                    BusinessAddress address = entity.getBusinessAddress();
                    List<KycSites> sites = entity.getKycSites();
                    List<RiskIndustry> riskIndustries = entity.getRiskIndustries();

                    if (identifiers == null || identifiers.isEmpty() || sites == null || sites.isEmpty()) continue;

                    for (Identifiers id : identifiers) {
                        String crdsCode = Optional.ofNullable(id.getCrdsCode()).orElse("");

                        String regAddress = (address != null)
                                ? Stream.of(address.getLine1(), address.getLine2(), address.getCity(), address.getState(), address.getZipcode())
                                .filter(Objects::nonNull)
                                .collect(Collectors.joining(" "))
                                : "";

                        String country = Optional.ofNullable(address).map(BusinessAddress::getCountry).orElse("");

                        KycSites site = sites.get(0); // Assuming only the first is required
                        String siteBnpp = Optional.ofNullable(site.getSiteBnpp()).orElse("");
                        String siteCountry = Optional.ofNullable(site.getCountry()).orElse("");
                        String siteStatus = Optional.ofNullable(site.getSiteStatus()).orElse("");

                        String kycSegment = Optional.ofNullable(entity.getKycSegment()).orElse("");

                        String ric = "";
                        if (riskIndustries != null && !riskIndustries.isEmpty()) {
                            RiskIndustry ri = riskIndustries.get(0);
                            ric = Optional.ofNullable(ri.getCode()).orElse("") + "-" + Optional.ofNullable(ri.getDescription()).orElse("");
                        }

                        String row = String.join(";", Arrays.asList(
                                crdsCode, regAddress, country, siteBnpp, siteCountry, siteStatus, kycSegment, ric
                        ));
                        writer.write(row);
                        writer.newLine();
                    }
                }

                writer.flush();
                log.info("Export completed successfully: {}", file.getAbsolutePath());
            }

        } catch (Exception e) {
            log.error("Error during export", e);
        }
    }
}
