package org.example.service;

import org.example.exception.ApiException;
import org.example.model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import javax.annotation.PostConstruct;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class EntityMergerService {

    private final List<MergedEntity> mergedEntities = Collections.synchronizedList(new ArrayList<>());
    private final RestTemplate restTemplate;

    @Value("${finance.api.url}")
    private String financeApiUrl;

    @Value("${kyc.api.url}")
    private String kycApiUrl;

    public EntityMergerService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @PostConstruct
    public void init() {
        loadAndMergeData();
    }

    private void loadAndMergeData() {
        try {
            FinanceFile financeData = restTemplate.getForObject(financeApiUrl, FinanceFile.class);
            KYCFile kycData = restTemplate.getForObject(kycApiUrl, KYCFile.class);

            if (financeData != null && kycData != null) {
                List<MergedEntity> newMerged = financeData.getResults().getEntities().stream()
                        .flatMap(financeEntity -> 
                            kycData.getResults().stream()
                                .flatMap(kycResult -> {
                                    KycData kycDataItem = kycResult.getKycData();
                                    return kycDataItem.getKyCsites().stream()
                                            .filter(kycSite -> containsIdentifier(financeEntity, kycSite.getSiteEntity()))
                                            .map(kycSite -> mergeEntities(financeEntity, kycDataItem, kycSite));
                                })
                        )
                        .collect(Collectors.toList());

                synchronized (mergedEntities) {
                    mergedEntities.clear();
                    mergedEntities.addAll(newMerged);
                }
            }
        } catch (Exception e) {
            throw new ApiException("Failed to merge data from APIs", e);
        }
    }

    private boolean containsIdentifier(Entity financeEntity, String kycSiteEntity) {
        return financeEntity.getIdentifiers().getPtyId().equals(kycSiteEntity);
    }

    private MergedEntity mergeEntities(Entity finance, KycData kycData, KYCsites kycSite) {
        MergedEntity merged = new MergedEntity();
        merged.setIdentifiers(finance.getIdentifiers());
        merged.setBusinessAddress(finance.getBusinessAddress());
        merged.setKyCsites(Collections.singletonList(kycSite));
        merged.setKyCsegment(kycData.getKyCsegment());
        merged.setRiskIndustry(kycData.getRiskIndustry());
        return merged;
    }

    public void refreshData() {
        loadAndMergeData();
    }

    public List<MergedEntity> getBySector(String sector) {
        synchronized (mergedEntities) {
            return mergedEntities.stream()
                    .filter(entity -> entity.getBusinessAddress().getCity().equalsIgnoreCase(sector)) // Adjust this based on your actual filtering logic
                    .collect(Collectors.toList());
        }
    }

    public Optional<MergedEntity> getByIdentifier(Identifiers identifier) {
        synchronized (mergedEntities) {
            return mergedEntities.stream()
                    .filter(entity -> entity.getIdentifiers().equals(identifier))
                    .findFirst();
        }
    }

    public List<MergedEntity> getAll() {
        synchronized (mergedEntities) {
            return new ArrayList<>(mergedEntities);
        }
    }
}
