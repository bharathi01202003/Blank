package org.example.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.example.model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

@Service
public class DataService {
    private final RestTemplate restTemplate;
    private final ObjectMapper mapper;

    @Value("${api.financech.url}")
    private String financeChUrl;
    
    @Value("${api.kyc.url}") 
    private String kycUrl;
    
    @Value("${auth.token.url}")
    private String authTokenUrl;
    
    @Value("${auth.basic.auth}")
    private String basicAuth;
    
    private String token;
    private final Set<String> processedPtyIds = Collections.synchronizedSet(new HashSet<>());

    public DataService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
        this.mapper = new ObjectMapper();
    }

    public List<MergedEntity> getMergedEntities() {
        try {
            fetchAuthToken();
            JsonNode financeResults = fetchJson(financeChUrl).path("results");
            
            System.out.println("\n‚ö° Starting processing of " + financeResults.size() + " entities");
            AtomicInteger successCount = new AtomicInteger(0);
            AtomicInteger errorCount = new AtomicInteger(0);

            List<MergedEntity> mergedEntities = StreamSupport.stream(financeResults.spliterator(), false)
                    .map(resultNode -> resultNode.path("entity"))
                    .filter(this::hasValidPtyId)
                    .filter(this::isFirstTimeProcessing)
                    .map(entityNode -> {
                        try {
                            MergedEntity merged = mergeForSinglePtyId(entityNode);
                            if (merged != null) {
                                successCount.incrementAndGet();
                            }
                            return merged;
                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                            return null;
                        }
                    })
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());

            System.out.println("\n‚úÖ Processing complete:");
            System.out.println("   - Total merged: " + successCount.get());
            System.out.println("   - Errors: " + errorCount.get());
            System.out.println("   - Final merged list size: " + mergedEntities.size());
            
            return mergedEntities;

        } catch (Exception e) {
            System.err.println("‚õî Critical error in getMergedEntities: " + e.getMessage());
            return Collections.emptyList();
        }
    }

    private boolean hasValidPtyId(JsonNode entityNode) {
        return entityNode.has("identifiers") && 
               entityNode.path("identifiers").has("ptyId");
    }

    private boolean isFirstTimeProcessing(JsonNode entityNode) {
        String ptyId = entityNode.path("identifiers").path("ptyId").asText();
        if (processedPtyIds.contains(ptyId)) {
            System.out.println("   ‚è≠Ô∏è Skipping duplicate ptyId: " + ptyId);
            return false;
        }
        processedPtyIds.add(ptyId);
        return true;
    }

    private MergedEntity mergeForSinglePtyId(JsonNode financeEntity) {
        String ptyId = financeEntity.path("identifiers").path("ptyId").asText();
        
        try {
            System.out.println("\nüîç Processing ptyId: " + ptyId);
            
            BusinessAddress address = mapper.convertValue(
                financeEntity.path("businessAddress"), 
                BusinessAddress.class
            );
            
            Identifiers identifiers = mapper.convertValue(
                financeEntity.path("identifiers"),
                Identifiers.class
            );

            JsonNode kycData = fetchKycData(ptyId);
            if (kycData == null) {
                return null;
            }

            List<KycSites> kycSites = parseKycSites(kycData.path("kycSites"));
            String kycSegment = kycData.path("kycSegment").asText(null);
            List<RiskIndustry> riskIndustries = parseRiskIndustries(kycData.path("riskIndustry"));

            return new MergedEntity(
                List.of(identifiers),
                address,
                kycSites,
                kycSegment,
                riskIndustries
            );

        } catch (Exception e) {
            System.err.println("‚ùå Failed to merge ptyId " + ptyId + ": " + e.getMessage());
            return null;
        }
    }

    private JsonNode fetchKycData(String ptyId) {
        try {
            String url = kycUrl + "?ptyId=" + ptyId;
            JsonNode response = fetchJson(url);
            JsonNode results = response.path("results");
            
            if (!results.isArray() || results.isEmpty()) {
                System.out.println("‚ö†Ô∏è No KYC data for ptyId: " + ptyId);
                return null;
            }
            
            return results.get(0).path("kycData");
        } catch (Exception e) {
            System.err.println("‚ùå KYC fetch failed for ptyId " + ptyId);
            return null;
        }
    }

    private List<KycSites> parseKycSites(JsonNode sitesNode) {
        try {
            return sitesNode.isArray() ?
                mapper.convertValue(sitesNode, new TypeReference<List<KycSites>>() {}) :
                Collections.emptyList();
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Failed to parse kycSites");
            return Collections.emptyList();
        }
    }

    private List<RiskIndustry> parseRiskIndustries(JsonNode riskNode) {
        try {
            return riskNode.isArray() ?
                mapper.convertValue(riskNode, new TypeReference<List<RiskIndustry>>() {}) :
                Collections.emptyList();
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Failed to parse riskIndustries");
            return Collections.emptyList();
        }
    }

    private void fetchAuthToken() {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
            headers.set("Authorization", basicAuth);
            headers.setAccept(List.of(MediaType.APPLICATION_JSON));

            ResponseEntity<String> response = restTemplate.postForEntity(
                authTokenUrl, 
                new HttpEntity<>("", headers), 
                String.class
            );

            validateAuthResponse(response);
            this.token = extractToken(response.getBody());
            
        } catch (Exception e) {
            throw new RuntimeException("üîí Authorization failed: " + e.getMessage());
        }
    }

    private void validateAuthResponse(ResponseEntity<String> response) {
        if (!response.getStatusCode().is2xxSuccessful()) {
            throw new RuntimeException("Auth API returned " + response.getStatusCode());
        }
    }

    private String extractToken(String responseBody) throws Exception {
        JsonNode json = mapper.readTree(responseBody);
        String token = json.path("access_token").asText();
        
        if (token == null || token.isBlank()) {
            throw new RuntimeException("Empty token in auth response");
        }
        
        return token;
    }

    private JsonNode fetchJson(String url) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setBearerAuth(token);
            headers.add("Accept", "*/*;version=gamma");

            ResponseEntity<String> response = restTemplate.exchange(
                url,
                HttpMethod.GET, 
                new HttpEntity<>(headers), 
                String.class
            );

            if (!response.getStatusCode().is2xxSuccessful()) {
                throw new RuntimeException("GET " + url + " failed: " + response.getStatusCode());
            }

            return mapper.readTree(response.getBody());
        } catch (Exception e) {
            throw new RuntimeException("Failed to fetch JSON: " + e.getMessage());
        }
    }
}
