package org.example.service;

import org.example.model.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;

@Service
public class EntityMergeService {

    private final WebClient webClient;
    
    @Value("${api.client.credentials}")
    private String clientCredentials;
    @Value("${api.auth-path}")
    private String authPath;
    @Value("${api.kyc-path}")
    private String kycPath;
    @Value("${api.finance-path}")
    private String financePath;

    public EntityMergeService(WebClient webClient) {
        this.webClient = webClient;
    }

    public Mono<List<MergedEntity>> mergeAllEntities() {
        return getAccessToken()
                .flatMap(token -> {
                    Mono<File2Root> kycDataMono = getKycData(token);
                    
                    return kycDataMono.flatMapMany(kycRoot -> Flux.fromIterable(kycRoot.getResults()))
                            .flatMap(kycResult -> {
                                Integer kycId = extractKycId(kycResult);
                                if (kycId == null) {
                                    return Mono.empty();
                                }
                                return getFinanceData(kycId.toString(), token)
                                        .map(financeRoot -> createMergedEntity(
                                                financeRoot.getResults().isEmpty() ? null : financeRoot.getResults().get(0).getEntity(),
                                                kycResult
                                        ));
                            })
                            .filter(mergedEntity -> mergedEntity != null)
                            .collectList();
                });
    }

    private Mono<String> getAccessToken() {
        return webClient.post()
                .uri(authPath)
                .header("Authorization", "Basic " + clientCredentials)
                .retrieve()
                .bodyToMono(String.class)
                .map(response -> {
                    if (response.contains("access_token")) {
                        return response.split("\"access_token\":\"")[1].split("\"")[0];
                    }
                    throw new RuntimeException("Failed to get access token");
                });
    }

    private Mono<File2Root> getKycData(String accessToken) {
        return webClient.get()
                .uri(kycPath)
                .header("Authorization", "Bearer " + accessToken)
                .retrieve()
                .bodyToMono(File2Root.class);
    }

    private Mono<File1Root> getFinanceData(String kycId, String accessToken) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .path(financePath)
                        .queryParam("kycId", kycId)
                        .build())
                .header("Authorization", "Bearer " + accessToken)
                .retrieve()
                .bodyToMono(File1Root.class);
    }

    private Integer extractKycId(File2Result kycResult) {
        return kycResult.getIdentifiers().stream()
                .map(Identifiers::getKycId)
                .findFirst()
                .orElse(null);
    }

    private MergedEntity createMergedEntity(Entity financeEntity, File2Result kycResult) {
        if (financeEntity == null) {
            return null;
        }
        
        MergedEntity merged = new MergedEntity();
        merged.setIdentifiers(kycResult.getIdentifiers());
        merged.setBusinessAddress(financeEntity.getBusinessAddress());
        
        if (kycResult.getKycData() != null) {
            merged.setKycSites(kycResult.getKycData().getKycSites());
            merged.setKycSegment(kycResult.getKycData().getKycSegment());
            merged.setRiskIndustry(kycResult.getKycData().getRiskIndustry());
        }
        
        return merged;
    }
}
