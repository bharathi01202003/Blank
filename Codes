@Service
public class AuthService {

    private final WebClient webClient;

    @Value("${auth.token.url}")
    private String tokenUrl;

    @Value("${auth.basic.token}")
    private String basicToken;

    public AuthService(WebClient.Builder builder) {
        this.webClient = builder.build();
    }

    public String fetchToken() {
        try {
            Map<String,Object> res = webClient.post()
                .uri(tokenUrl)
                .header("Accept","*/*;version=gamma")
                .header("Authorization","Basic " + basicToken)
                .retrieve()
                .bodyToMono(new ParameterizedTypeReference<Map<String,Object>>() {})
                .block();

            if (res!=null && res.containsKey("access_token"))
                return (String) res.get("access_token");
            throw new RuntimeException("No access_token in response");
        } catch (Exception e) {
            // Log and return null – downstream must handle
            System.err.println("⚠️ Auth token fetch failed: " + e.getMessage());
            return null;
        }
    }
}



@RestController
public class MergerController {

    private final DataService ds;

    public MergerController(DataService ds){
        this.ds=ds;
    }

    @GetMapping("/merged-results")
    public List<MergedEntity> merged() {
        return ds.fetchMergedData();
    }
}



package org.example.service;

import org.example.model.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

import java.util.*;

@Service
public class DataService {

    private final WebClient webClient;
    private final AuthService authService;
    private static final Logger logger = LoggerFactory.getLogger(DataService.class);

    @Value("${api.finance.url}")
    private String financeUrl;

    @Value("${api.kyc.url}")
    private String kycUrl;

    public DataService(WebClient.Builder builder, AuthService authService) {
        this.webClient = builder.build();
        this.authService = authService;
    }

    public List<MergedEntity> fetchMergedData() {
        String token = authService.fetchToken();
        if (token == null) {
            logger.error("⚠️ Could not fetch auth token. Skipping data fetch.");
            return Collections.emptyList();
        }

        File1Root financeData = fetch(financeUrl, File1Root.class, token);
        File2Root kycData = fetch(kycUrl, File2Root.class, token);

        if (financeData == null || kycData == null) {
            logger.warn("⚠️ One or both API responses are null. Returning empty merged list.");
            return Collections.emptyList();
        }

        return mergeData(financeData, kycData);
    }

    private <T> T fetch(String url, Class<T> clazz, String token) {
        try {
            logger.info("Fetching from URL: {}", url);
            return webClient.get()
                    .uri(url)
                    .header("Accept", "*/*;version=gamma")
                    .header("Authorization", "Bearer " + token)
                    .retrieve()
                    .bodyToMono(clazz)
                    .block();
        } catch (Exception e) {
            logger.error("❌ API call failed for URL {}: {}", url, e.getMessage());
            return null;
        }
    }

    private List<MergedEntity> mergeData(File1Root financeData, File2Root kycData) {
        List<MergedEntity> result = new ArrayList<>();

        for (File1Result finance : financeData.getResults()) {
            if (finance.getEntity() == null || finance.getEntity().getIdentifiers() == null)
                continue;

            Identifiers financeId = finance.getEntity().getIdentifiers();

            Optional<File2Result> match = kycData.getResults().stream()
                    .filter(kyc -> kyc.getIdentifiers() != null && !kyc.getIdentifiers().isEmpty()
                            && financeId.getPtyId().equals(kyc.getIdentifiers().get(0).getPtyId()))
                    .findFirst();

            match.ifPresent(kyc -> {
                MergedEntity merged = new MergedEntity();
                merged.setIdentifiers(Collections.singletonList(financeId));
                merged.setBusinessAddress(finance.getEntity().getBusinessAddress());

                KycData kd = kyc.getKycData();
                if (kd != null) {
                    merged.setKycSites(kd.getKycSites());
                    merged.setKycSegment(kd.getKycSegment());
                    merged.setRiskIndustry(kd.getRiskIndustry());
                }

                result.add(merged);
            });
        }

        logger.info("✅ Merged {} entities from finance and KYC data.", result.size());
        return result;
    }
}


